p + coord_cartesian(xlim = c(0,3), ylim = c(0, 3))
View(df_trim1)
df_trim1 <- read.csv(file_path)
View(df_trim1)
View(df_trim1)
p <- ggplot(df_trim1, aes(x = PCT90, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(0,3), ylim = c(0, 3))
p <- ggplot(df_trim1, aes(x = PCT90, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(0,5), ylim = c(0, 3))
p <- ggplot(df_trim1, aes(x = PCT90, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
p <- ggplot(df_trim1, aes(x = MEDIAN, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
p <- ggplot(df_trim1, aes(x = MEAN, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
p <- ggplot(df_trim1, aes(x = PCT90, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
# Shapiro-Wilk test for backs
shapiro.test(df_trim1$backs)
# Shapiro-Wilk test for backs
shapiro.test(df_trim1$'backs')
# Shapiro-Wilk test for backs
shapiro.test(df_trim1[[backs]])
#Check if data is normally distributed
# Shapiro-Wilk test for ERA5
backs <- "MEAN"
# Shapiro-Wilk test for backs
shapiro.test(df_trim1[[backs]])
backs <- "MEAN"
# Shapiro-Wilk test for backs
shapiro.test(df_trim1[[backs]])
hist(df_trim1[[backs]], main = "Histogram for backs")
# Q-Q plot for backs
qqnorm(df_trim1[[backs]])
qqline(df_trim1[[backs]])
hist(df_trim1[[backs]], main = "Histogram for backs")
backs <- "MEAN"
# Shapiro-Wilk test for backs
shapiro.test(df_trim1[[backs]])
hist(df_trim1[[backs]], main = "Histogram for backs")
# Q-Q plot for backs
# Create a QQ plot using qqnorm()
qqnorm(df_trim1[[backs]])
qqline(df_trim1[[backs]])
ggqqplot(df_trim1[[backs]])
#TESGING
library("ggpubr")
ggqqplot(df_trim1[[backs]])
df_trim1 <- df_trim1[df_trim1$ERA5 > 1, ]
#TESGING
library("ggpubr")
ggqqplot(df_trim1[[backs]])
file_path <- "data/marsVH_augustVV_coregistered_point_buffer_zonal.csv"
df_trim1 <- read.csv(file_path)
p <- ggplot(df_trim1, aes(x = PCT90, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
#TESGING
library("ggpubr")
ggqqplot(df_trim1[[backs]])
backs <- "MEAN"
# Shapiro-Wilk test for backs
shapiro.test(df_trim1[[backs]])
hist(df_trim1[[backs]], main = "Histogram for backs")
# Q-Q plot for backs
# Create a QQ plot using qqnorm()
qqnorm(df_trim1[[backs]])
qqline(df_trim1[[backs]])
ggqqplot(df_trim1[[backs]])
p <- ggplot(df_trim1, aes(x = MEAN, y = ERA5)) +
geom_line()
p <- ggplot(df_trim1, aes(x = MEAN, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
backs <- "MEAN"
# Shapiro-Wilk test for backs
shapiro.test(df_trim1[[backs]])
hist(df_trim1[[backs]], main = "Histogram for backs")
# Q-Q plot for backs
# Create a QQ plot using qqnorm()
qqnorm(df_trim1[[backs]])
qqline(df_trim1[[backs]])
ggqqplot(df_trim1[[backs]])
# Store the result in a variable
#cor_result <- cor.test( df_trim1$backs,df_trim1$ERA5, method = "spearman")
cor_result <- cor.test( df_trim1$backs,df_trim1$ERA5, method = "spearman", exact = FALSE)
#MEAN MEDIAN PCT90
backs <- "MEAN"
p <- ggplot(df_trim1, aes(x = backs, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
p <- ggplot(df_trim1, aes(x = [[backs]]â˜º, y = ERA5)) +
p <- ggplot(df_trim1, aes(x = [[backs]], y = ERA5)) +
#MEAN MEDIAN PCT90
backs <- "MEAN"
p <- ggplot(df_trim1, aes(x = [backs], y = ERA5)) +
p <- ggplot(df_trim1, aes(x = backs, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
#MEAN MEDIAN PCT90
backs <- "PCT90"
p <- ggplot(df_trim1, aes(x = backs, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
#MEAN MEDIAN PCT90
backs <- 'PCT90
p <- ggplot(df_trim1, aes(x = backs, y = ERA5)) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
p <- ggplot(df_trim1, aes_string(x = backs, y = "ERA5")) +
geom_line()
# Limit the axes
p + coord_cartesian(xlim = c(1.5,5), ylim = c(0, 3))
shapiro.test(df_trim1$ERA5)
hist(df_trim1$ERA5, main = "Histogram for ERA5")
# Q-Q plot for ERA5
qqnorm(df_trim1$ERA5)
qqline(df_trim1$ERA5, col = 2)
# Shapiro-Wilk test for backs
shapiro.test(df_trim1[[backs]])
hist(df_trim1[[backs]], main = "Histogram for backs")
# Q-Q plot for backs
# Create a QQ plot using qqnorm()
qqnorm(df_trim1[[backs]])
qqline(df_trim1[[backs]])
ggqqplot(df_trim1[[backs]])
# Store the result in a variable
#cor_result <- cor.test( df_trim1$backs,df_trim1$ERA5, method = "spearman")
cor_result <- cor.test(df_trim1[[backs]],df_trim1$ERA5, method = "spearman", exact = FALSE)
# Access the correlation coefficient and p-value
cor_coef <- cor_result$estimate
p_value <- cor_result$p.value
cat("Spearman's rank correlation coefficient:", cor_coef, "\n")
cat("P-value:", p_value, "\n")
# Assuming df_trim1 is your data frame
correlation_result <- cor.test(df_trim1$backs, df_trim1$ERA5, method = "pearson")
# Assuming df_trim1 is your data frame
correlation_result <- cor.test(df_trim1[[backs]], df_trim1$ERA5, method = "pearson")
# Print the results
print(correlation_result)
correlation_result$estimate
knitr::opts_chunk$set(echo = TRUE)
pathPrep <- function(path = "clipboard") {
y <- if (path == "clipboard") {
readClipboard()
} else {
cat("Please enter the path:\n\n")
readline()
}
x <- chartr("\\", "/", y)
writeClipboard(x)
return(x)
}
"C:\Users\trygg\Documents\Master_project\Data\Vindefjallen_data\Snowdepth_data.xlsx"
pathp("C:\Users\trygg\Documents\Master_project\Data\Vindefjallen_data\Snowdepth_data.xlsx")
pathPrep()
C:/Users/trygg/Documents/Master_project/Data/Vindefjallen_data/Snowdepth_data.xlsx
pathPrep()
pathPrep <- function(path = "clipboard") {
y <- if (path == "clipboard") {
readClipboard()
} else {
cat("Please enter the path:\n\n")
readline()
}
x <- chartr("\\", "/", y)
writeClipboard(x)
return(x)
}
pathprep
y <- if (path == "clipboard") {
readClipboard()
} else {
cat("Please enter the path:\n\n")
readline()
}
writeClipboard(x)
C:/Users/trygg/Documents/Master_project/Data/Vindefjallen_data/Snowdepth_data.xlsx
writeClipboard(x)
pathPrep <- function(path = "clipboard") {
y <- if (path == "clipboard") {
readClipboard()
} else {
cat("Please enter the path:\n\n")
readline()
}
x <- chartr("\\", "/", y)
writeClipboard(x)
return(x)
}
pathPrep <- function(path = "clipboard") {
y <- if (path == "clipboard") {
readClipboard()
} else {
cat("Please enter the path:\n\n")
readline()
}
x <- chartr("\\", "/", y)
writeClipboard(x)
return(x)
}
C:/Users/trygg/Documents/Master_project/Data/Vindefjallen_data/Snowdepth_data.xlsx
pathPrep <- function(path = "clipboard") {
y <- if (path == "clipboard") {
readClipboard()
} else {
cat("Please enter the path:\n\n")
readline()
}
x <- chartr("\\", "/", y)
writeClipboard(x)
return(x)
}
C:/Users/trygg/Documents/Master_project/Data/Vindefjallen_data/Snowdepth_data.xlsx
pathPrep()
pathPrep(C:/Users/trygg/Documents/Master_project/Data/Vindefjallen_data/Snowdepth_data.xlsx)
pathPrep("C:/Users/trygg/Documents/Master_project/Data/Vindefjallen_data/Snowdepth_data.xlsx")
file_path <- "C:\\Users\\trygg\\Documents\\Master_project\\Data\\Vindefjallen_data\\Snowdepth_data.xlsx"
# Read the CSV file and store it in a dataframe
snow_depth_df <- read.csv(file_path)
# Install and load the openxlsx package
# install.packages("openxlsx")
library(openxlsx)
install.packages("openxlsx")
# Install and load the openxlsx package
# install.packages("openxlsx")
library(openxlsx)
# Specify the file path
file_path <- "C:/Users/trygg/Documents/Master_project/Data/Vindefjallen_data/Snowdepth_data.xlsx"
# Read the Excel file
my_data <- read.xlsx(file_path)
# Display the first few rows of the data
head(my_data)
View(my_data)
# Display the first few rows of the data
head(my_data)
columns_to_keep <- c("Triangle", "CensusDate", "CensusYear", "SnowDepth_cornerA_cm", "SnowDepth_cornerB_cm", "SnowDepth_cornerC_cm", "Temperature_degreeCelsius")
# Subset the dataframe to keep only the selected columns
my_data_trim <- my_data[, columns_to_keep]
View(my_data_trim)
# Assuming "Triangle" is the column name in my_data_trim
unique_triangles <- unique(my_data_trim$Triangle)
num_unique_triangles <- length(unique_triangles)
# Print the count of unique entries
cat("Number of unique entries in the 'Triangle' column:", num_unique_triangles, "\n")
# Convert the entire column to Date format
my_data_trim$CensusDate <- as.Date(my_data_trim$CensusDate, origin = "1970-01-01")
# Print the first few rows of the updated data frame
head(my_data_trim)
# Specify the file path
file_path <- "C:/Users/trygg/Documents/Master_project/Data/Vindefjallen_data/Snowdepth_data.xlsx"
# Read the Excel file
my_data <- read.xlsx(file_path)
columns_to_keep <- c("ID","Triangle", "CensusDate", "CensusYear", "SnowDepth_cornerA_cm", "SnowDepth_cornerB_cm", "SnowDepth_cornerC_cm", "Temperature_degreeCelsius")
# Subset the dataframe to keep only the selected columns
my_data_trim <- my_data[, columns_to_keep]
# Convert the entire column to Date format
my_data_trim$CensusDate <- as.Date(my_data_trim$CensusDate, origin = "1970-01-01")
# Install and load the openxlsx package
# install.packages("openxlsx")
library(openxlsx)
# Specify the file path
file_path <- "C:/Users/trygg/Documents/Master_project/Data/Vindefjallen_data/Snowdepth_data.xlsx"
# Read the Excel file
my_data <- read.xlsx(file_path)
# Display the first few rows of the data
columns_to_keep <- c("ID","Triangle", "CensusDate", "CensusYear", "SnowDepth_cornerA_cm", "SnowDepth_cornerB_cm", "SnowDepth_cornerC_cm", "Temperature_degreeCelsius")
# Subset the dataframe to keep only the selected columns
my_data_trim <- my_data[, columns_to_keep]
# Assuming my_data_trim is your data frame
# Replace "CensusDate" with the actual column name
# Convert the entire column to Date format
my_data_trim$CensusDate <- as.Date(my_data_trim$CensusDate, origin = "1899-12-30")
# Print the first few rows of the updated data frame
head(my_data_trim)
knitr::opts_chunk$set(echo = TRUE)
# Assuming my_data_trim is your dataframe
# and CensusDate is the column you are interested in
# Use table() to count the occurrences of each unique value
census_date_counts <- table(my_data_trim$CensusDate)
# Convert the result to a data frame for better readability
census_date_counts_df <- as.data.frame(census_date_counts)
# Print or view the result
print(census_date_counts_df)
# Assuming my_data_trim is your dataframe
# and CensusDate is the column you are interested in
# Use table() to count the occurrences of each unique value
census_date_counts <- table(my_data_trim$CensusDate)
# Convert the result to a data frame for better readability
census_date_counts_df <- as.data.frame(census_date_counts)
# Order the data frame by frequency in descending order
census_date_counts_df <- census_date_counts_df[order(-census_date_counts_df$Freq), ]
# Print or view the result
print(census_date_counts_df)
#Counting how often each triangle has been measured
# Assuming my_data_trim is your dataframe
# and Triangle is the column you are interested in
# Use table() to count the occurrences of each unique value
triangle_counts <- table(my_data_trim$Triangle)
# Convert the result to a data frame for better readability
triangle_counts_df <- as.data.frame(triangle_counts)
triangle_counts_df <- triangle_counts_df[order(-triangle_counts_df$Freq), ]
# Print or view the result
print(triangle_counts_df)
View(census_date_counts_df)
View(triangle_counts_df)
View(triangle_counts_df)
write.xlsx(triangle_counts_df, "temp\\triangles.xlsx", rowNames = FALSE)
#write.xlsx(triangle_counts_df, "temp\\triangles.xlsx", rowNames = FALSE)
library(openxlsx)
write.xlsx(triangle_counts_df, "temp\\triangles.xlsx", rowNames = FALSE)
write.xlsx(census_date_counts_df, "temp\\census_dates.xlsx", rowNames = FALSE)
pathPrep <- function(path = "clipboard") {
y <- if (path == "clipboard") {
readClipboard()
} else {
cat("Please enter the path:\n\n")
readline()
}
x <- chartr("\\", "/", y)
writeClipboard(x)
return(x)
}
C:\Users\trygg\Documents\Master_project\Testing\Vindefjallen_testing\data\Snowdepth_data - Copy.xlsx
pathPrep <- function(path = "clipboard") {
y <- if (path == "clipboard") {
readClipboard()
} else {
cat("Please enter the path:\n\n")
readline()
}
x <- chartr("\\", "/", y)
writeClipboard(x)
return(x)
}
pathPrep <- function(path = "clipboard") {
y <- if (path == "clipboard") {
readClipboard()
} else {
cat("Please enter the path:\n\n")
readline()
}
x <- chartr("\\", "/", y)
writeClipboard(x)
return(x)
}
pathPrep()
"C:/Users/trygg/Documents/Master_project/Testing/Vindefjallen_testing/data/Snowdepth_data - Copy.xlsx"
pathPrep()
C:/Users/trygg/Documents/Master_project/Testing/Vindefjallen_testing/data/Snowdepth_data - Copy.xlsx
pathPrep()
#data processing for adding x and y coords to each measurement
# Install and load the readxl package
install.packages("readxl")
#data processing for adding x and y coords to each measurement
# Install and load the readxl package
install.packages("readxl")
library(readxl)
# Specify the file path to your Excel file
excel_file_path <- "C:\\Users\\trygg\\Documents\\Master_project\\Testing\\Vindefjallen_testing\\data\\Snowdepth_data - Copy.xlsx"
# Specify the sheet name or index (e.g., "Sheet1" or 1)
sheet_name <- "Census_data_granune_matching"
# Read the specific sheet into a data frame
data <- read_excel(excel_file_path, sheet = sheet_name)
# Print the first few rows of the data frame
print(head(data))
sheet_name <- "Triangle_infos"
triangle_data = read_excel(excel_file_path, sheet = sheet_name)
print(head(triangle_data))
# Specify the file path to your Excel file
excel_file_path <- "C:\\Users\\trygg\\Documents\\Master_project\\Testing\\Vindefjallen_testing\\data\\Snowdepth_data - Copy.xlsx"
# Specify the sheet name or index (e.g., "Sheet1" or 1)
sheet_name <- "Census_data_granune_matching"
# Read the specific sheet into a data frame
census_data <- read_excel(excel_file_path, sheet = sheet_name)
# Print the first few rows of the data frame
print(head(census_data))
sheet_name <- "Triangle_infos"
triangle_data = read_excel(excel_file_path, sheet = sheet_name)
print(head(triangle_data))
# Specify the file path to your Excel file
excel_file_path <- "C:\\Users\\trygg\\Documents\\Master_project\\Testing\\Vindefjallen_testing\\data\\Snowdepth_data - Copy.xlsx"
# Specify the sheet name or index (e.g., "Sheet1" or 1)
sheet_name <- "Census_data_granune_matching"
# Read the specific sheet into a data frame
census_data <- read_excel(excel_file_path, sheet = sheet_name)
# Print the first few rows of the data frame
print(head(census_data))
sheet_name <- "Triangle_infos"
triangle_data = read_excel(excel_file_path, sheet = sheet_name)
View(triangle_data)
# Specify the file path to your Excel file
excel_file_path <- "C:\\Users\\trygg\\Documents\\Master_project\\Testing\\Vindefjallen_testing\\data\\Snowdepth_data - Copy.xlsx"
# Specify the sheet name or index (e.g., "Sheet1" or 1)
sheet_name <- "Census_data_granune_matching"
# Read the specific sheet into a data frame
census_data <- read_excel(excel_file_path, sheet = sheet_name)
# Print the first few rows of the data frame
print(head(census_data))
sheet_name <- "Triangle_infos_altered"
triangle_data = read_excel(excel_file_path, sheet = sheet_name)
sheet_name <- "triangle_infos_altered"
triangle_data = read_excel(excel_file_path, sheet = sheet_name)
View(triangle_data)
View(census_data)
# Install and load the tidyverse package
install.packages("tidyverse")
library(tidyverse)
# Assuming triangle_data is your data frame
# You can create a new column named "Merged_Column" by concatenating "Triangle" and "Corner"
triangle_data <- triangle_data %>%
mutate(Merged_Column = paste(Triangle, Corner, sep = ""))
# Print the updated data frame
print(triangle_data)
#data processing for adding x and y coords to each measurement
# Specify the file path to your Excel file
excel_file_path <- "C:\\Users\\trygg\\Documents\\Master_project\\Testing\\Vindefjallen_testing\\data\\Snowdepth_data - Copy.xlsx"
# Specify the sheet name or index (e.g., "Sheet1" or 1)
sheet_name <- "Census_data_granune_matching"
# Read the specific sheet into a data frame
census_data <- read_excel(excel_file_path, sheet = sheet_name)
# Print the first few rows of the data frame
print(head(census_data))
sheet_name <- "triangle_infos_altered"
triangle_data = read_excel(excel_file_path, sheet = sheet_name)
print(head(triangle_data))
knitr::opts_chunk$set(echo = TRUE)
# Install and load the openxlsx package
# install.packages("openxlsx")
library(openxlsx)
library(tidyverse)
#Create a new column which combines Triangle and Corner
# Assuming triangle_data is your data frame
# You can create a new column named "Merged_Column" by concatenating "Triangle" and "Corner"
triangle_data <- triangle_data %>%
mutate(TriangleCorner = paste(Triangle, Corner, sep = ""))
# Print the updated data frame
print(triangle_data)
View(triangle_data)
View(census_data)
census_data <- census_data %>%
mutate(TriangleCorner = paste(Triangle, Corner, sep = ""))
View(census_data)
View(triangle_data)
merged_data <- left_join(census_data, triangle_data, by = "TriangleCorner")
View(merged_data)
print(head(merged_data))
columns_to_keep <- c("ID","Triangle.x
", "Corner.x", "CensusDate", "SnowDepth", "TriangleCorner", "xcoord_EPSG_3006", "ycoord_EPSG_3006")
# Subset the dataframe to keep only the selected columns
merged_data_trim <- my_data[, columns_to_keep]
# Subset the dataframe to keep only the selected columns
merged_data_trim <- merged_data[, columns_to_keep]
print(head(merged_data))
columns_to_keep <- c("ID","Triangle.x", "Corner.x", "CensusDate", "SnowDepth", "TriangleCorner", "xcoord_EPSG_3006", "ycoord_EPSG_3006")
# Subset the dataframe to keep only the selected columns
merged_data_trim <- merged_data[, columns_to_keep]
print(head(merged_data))
print(head(merged_data_trim))
# Specify the file path for the CSV file
output_path <- "C:/Users/trygg/Documents/Master_project/Testing/Vindefjallen_testing/data/vindefjallen_corner_coords.csv"
# Export the data frame to a CSV file
write.csv(merged_data_trim, file = output_path, row.names = FALSE)
# Optionally, print a message to confirm the export
cat("Data exported to:", output_path, "\n")
summary(merged_data_trim)
str(merged_data_trim)
merged_data_trim$CensusDate <- as.character(merged_data_trim$CensusDate)
str(merged_data_trim)
# Specify the file path for the CSV file
output_path <- "C:/Users/trygg/Documents/Master_project/Testing/Vindefjallen_testing/data/vindefjallen_corner_coords.csv"
# Export the data frame to a CSV file
write.csv(merged_data_trim, file = output_path, row.names = FALSE)
View(merged_data_trim)
print(head(merged_data_trim))
library(sf)
# Create an sf object with EPSG:3006 coordinates
sf_data_3006 <- st_as_sf(merged_data_trim, coords = c("xcoord_EPSG_3006", "ycoord_EPSG_3006"), crs = 3006)
# Transform the coordinates to EPSG:4326
sf_data_4326 <- st_transform(sf_data_3006, crs = 4326)
# Add the transformed coordinates back to the original data frame
merged_data_trim$xcoord_EPSG_4326 <- st_coordinates(sf_data_4326)[, 1]
merged_data_trim$ycoord_EPSG_4326 <- st_coordinates(sf_data_4326)[, 2]
# Optionally, drop the original EPSG:3006 coordinates
merged_data_trim <- merged_data_trim[, !(names(merged_data_trim) %in% c("xcoord_EPSG_3006", "ycoord_EPSG_3006"))]
# Print the updated data frame
print(merged_data_trim)
#export to excel
# Assuming merged_data_trim is your data frame
merged_data_trim$CensusDate <- as.character(merged_data_trim$CensusDate)
# Specify the file path for the CSV file
output_path <- "C:/Users/trygg/Documents/Master_project/Testing/Vindefjallen_testing/data/vindefjallen_corner_coords.csv"
# Export the data frame to a CSV file
write.csv(merged_data_trim, file = output_path, row.names = FALSE)
